(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{378:function(e,v,t){"use strict";t.r(v);var a=t(45),_=Object(a.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"基于我自己面试中经常遇到的问题-仅供参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于我自己面试中经常遇到的问题-仅供参考"}},[e._v("#")]),e._v(" 基于我自己面试中经常遇到的问题（仅供参考）")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"组件化开发时为什么data是一个函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件化开发时为什么data是一个函数"}},[e._v("#")]),e._v(" 组件化开发时为什么data是一个函数")]),e._v(" "),t("p",[e._v("组件的data写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一分新的data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份data，就会造成一个变了全都会变的结果。")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"vue组件通讯有哪些方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue组件通讯有哪些方式"}},[e._v("#")]),e._v(" Vue组件通讯有哪些方式？")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("props 和 $emit。父组件向子组件传递数据是通过props传递的，子组件传递给父组件是通过$emit触发事件来做到的。")])]),e._v(" "),t("li",[t("p",[e._v("$refs 获取组件实例。")])]),e._v(" "),t("li",[t("p",[e._v("envetBus 兄弟组件数据传递，这种情况下可以使用事件总线的方式。")])]),e._v(" "),t("li",[t("p",[e._v("vuex 状态管理")])]),e._v(" "),t("li",[t("p",[e._v("使用消息订阅与发布相关的插件\n** 还有其他方法，我个人还没有了解过 **")])])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"vue的生命周期方法有哪些-一般在哪一步发送请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue的生命周期方法有哪些-一般在哪一步发送请求"}},[e._v("#")]),e._v(" Vue的生命周期方法有哪些？一般在哪一步发送请求？")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("beforeCreate 在实例初始化之后，数据观测（data observe）和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。")])]),e._v(" "),t("li",[t("p",[e._v("created 实例已经创建完成之后被调用。在这一步，实例已经完成以下的配置：数据观测（data observe ），属性和方法的运算，watch/event 事件回调。这里没有 $el，如果非要想与 DOM 进行交互，可以通过vm.$nextTick 来访问 DOM。")])]),e._v(" "),t("li",[t("p",[e._v("beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。")])]),e._v(" "),t("li",[t("p",[e._v("mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom节点。")])]),e._v(" "),t("li",[t("p",[e._v("beforeUpdate 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁 （patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。")])]),e._v(" "),t("li",[t("p",[e._v("updated 发生在更新完成之后，当前阶段组件 Dom 已经完成更新。要注意的是避免在此期间更新数据，因为这个可能导致无限循环的更新，该钩子在服务器渲染期间不被调用。")])]),e._v(" "),t("li",[t("p",[e._v("beforeDestroy 实例销毁之前调用。在这一步，实力仍然完全可用。我们可以在这时进行 善后收尾工作，比如清除定时器。")])]),e._v(" "),t("li",[t("p",[e._v("destroy Vue实例销毁后调用。调用后，Vue实例指示的东西都会解绑定，所有的事件监听器会被移除，左右的子实例也会被销毁，该钩子在服务器端渲染不被调用。")])]),e._v(" "),t("li",[t("p",[e._v("activated keep-alive 专属，组件被激活时调用")])]),e._v(" "),t("li",[t("p",[e._v("deactivated keep-alive 专属，组件被销毁时调用")])]),e._v(" "),t("li",[t("p",[e._v("nextTick 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。(也是钩子函数的一种，不在生命周期中)")])])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[e._v("#")]),e._v(" v-if 和 v-show 的区别")]),e._v(" "),t("p",[e._v("v-if 在编译过程中会被转化成三元表达式，条件不满足时不渲染此节点。")]),e._v(" "),t("p",[e._v("v-show 会被编译成指令，条件不满足时控制样式将此节点隐藏（display:none）\n"),t("strong",[e._v("使用场景")]),e._v("\nv-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景。")]),e._v(" "),t("p",[e._v("v-show 适用于需要非常频繁切换条件的场景。")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"说说-vue-内置指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#说说-vue-内置指令"}},[e._v("#")]),e._v(" 说说 vue 内置指令")]),e._v(" "),t("p",[e._v("v-once - 定义它的元素或组件只渲染一次，包括元素或组件的所有节点，首次渲染后，不再随数据的变化重新渲染，将被视为静态内容。\nv-cloak - 这个指令保持在元素上直到关联实例结束编译 -- 解决初始化慢到页面闪动的最佳实践。\nv-bind - 绑定属性，动态更新HTML元素上的属性。例如 v-bind:class。\nv-on - 用于监听DOM事件。例如 v-on:click v-on:keyup\nv-html - 赋值就是变量的innerHTML -- 注意防止xss攻击\nv-text - 更新元素的textContent\nv-model - 1、在普通标签。变成value和input的语法糖，并且会处理拼音输入法的问题。2、再组件上。也是处理value和input语法糖。\nv-if / v-else / v-else-if。可以配合template使用；在render函数里面就是三元表达式。\nv-show - 使用指令来实现 -- 最终会通过display来进行显示隐藏\nv-for - 循环指令编译出来的结果是 -L 代表渲染列表。优先级比v-if高最好不要一起使用，尽量使用计算属性去解决。注意增加唯一key值，建议不要使用index作为key。\nv-pre - 跳过这个元素以及子元素的编译过程，以此来加快整个项目的编译速度")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"vue-2-0-响应式数据的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-2-0-响应式数据的原理"}},[e._v("#")]),e._v(" Vue 2.0 响应式数据的原理")]),e._v(" "),t("p",[e._v("整体思路是数据劫持 + 观察者模式")]),e._v(" "),t("p",[e._v("对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存在它所依赖的 watcher （依赖收集）get，当属性变化后会通知自己对应的 watcher 去更新（派发更新）set。")]),e._v(" "),t("ol",[t("li",[e._v("Object.defineProperty 数据劫持")]),e._v(" "),t("li",[e._v("使用 getter 收集依赖 ，setter 通知 watcher派发更新。")]),e._v(" "),t("li",[e._v("watcher 发布订阅模式。")])]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"v-model-原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-model-原理"}},[e._v("#")]),e._v(" v-model 原理")]),e._v(" "),t("p",[e._v("其核心就是，一方面modal层通过defineProperty来劫持每个属性，一旦监听到变化通过相关的页面元素更新。另一方面通过编译模板文件，为控件的v-model绑定input事件，从而页面输入能实时更新相关data属性值。")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"keep-alive-使用场景和原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-使用场景和原理"}},[e._v("#")]),e._v(" keep-alive 使用场景和原理")]),e._v(" "),t("p",[e._v("keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。")]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"vue-set-方法原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-set-方法原理"}},[e._v("#")]),e._v(" Vue.$set 方法原理")]),e._v(" "),t("p",[e._v("在两种情况下修改 Vue 是不会触发视图更新的。")]),e._v(" "),t("ol",[t("li",[e._v("在实例创建之后添加新的属性到实例上（给响应式对象新增属性）")]),e._v(" "),t("li",[e._v("直接更改数组下标来修改数组的值。\n$set 原理如下\n因为响应式数据 我们给对象和数组本身新增了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性，首先会把新的属性进行响应式跟踪 然后会触发对象 "),t("strong",[e._v("ob")]),e._v(" 的dep收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组。")])])])}),[],!1,null,null,null);v.default=_.exports}}]);